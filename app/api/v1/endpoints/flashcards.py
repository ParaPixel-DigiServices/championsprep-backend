"""
Simple Flashcard System - Uses AI-Generated Flashcards
Just retrieves and practices flashcards that were already generated by AI
"""

from fastapi import APIRouter, Depends, HTTPException, Query
from typing import List, Optional
from datetime import datetime
import uuid

from app.api.v1.dependencies import get_current_user
from app.db.supabase import supabase
from app.models.auth import UserResponse as User

router = APIRouter(prefix="/flashcards", tags=["Flashcards"])


# ============================================================================
# GET AI-GENERATED FLASHCARDS
# ============================================================================

@router.get("/chapter/{chapter_id}")
async def get_chapter_flashcards(
    chapter_id: str,
    current_user: User = Depends(get_current_user)
):
    """
    Get AI-generated flashcards for a chapter.
    These were automatically created when the material was processed.
    """
    try:
        # Get flashcard content for this chapter
        result = supabase.table("ai_generated_content").select("*").eq(
            "chapter_id", chapter_id
        ).eq("content_type", "flashcard").execute()
        
        if not result.data:
            return {
                "chapter_id": chapter_id,
                "flashcards": [],
                "total": 0,
                "message": "No flashcards generated for this chapter yet"
            }
        
        # Extract flashcards from content array
        all_flashcards = []
        for item in result.data:
            content = item.get("content", [])
            if isinstance(content, list):
                for idx, card in enumerate(content):
                    if isinstance(card, dict):
                        all_flashcards.append({
                            "id": f"{item['id']}_f{idx}",
                            "front": card.get("front", ""),
                            "back": card.get("back", ""),
                            "difficulty": card.get("difficulty", "medium")
                        })
        
        return {
            "chapter_id": chapter_id,
            "flashcards": all_flashcards,
            "total": len(all_flashcards)
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to get flashcards: {str(e)}")


@router.get("/topic/{topic_id}")
async def get_topic_flashcards(
    topic_id: str,
    current_user: User = Depends(get_current_user)
):
    """Get AI-generated flashcards for a specific topic."""
    try:
        result = supabase.table("ai_generated_content").select("*").eq(
            "topic_id", topic_id
        ).eq("content_type", "flashcard").execute()
        
        if not result.data:
            return {
                "topic_id": topic_id,
                "flashcards": [],
                "total": 0
            }
        
        # Extract flashcards
        all_flashcards = []
        for item in result.data:
            content = item.get("content", [])
            if isinstance(content, list):
                for idx, card in enumerate(content):
                    if isinstance(card, dict):
                        all_flashcards.append({
                            "id": f"{item['id']}_f{idx}",
                            "front": card.get("front", ""),
                            "back": card.get("back", ""),
                            "difficulty": card.get("difficulty", "medium")
                        })
        
        return {
            "topic_id": topic_id,
            "flashcards": all_flashcards,
            "total": len(all_flashcards)
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to get flashcards: {str(e)}")


# ============================================================================
# PRACTICE SESSION
# ============================================================================

@router.post("/session/start")
async def start_flashcard_session(
    chapter_id: str = Query(..., description="Chapter to practice"),
    current_user: User = Depends(get_current_user)
):
    """Start a flashcard practice session."""
    try:
        # Get flashcards for chapter
        flashcards_response = await get_chapter_flashcards(chapter_id, current_user)
        
        if not flashcards_response["flashcards"]:
            raise HTTPException(status_code=404, detail="No flashcards available for this chapter")
        
        # Create session
        session_id = str(uuid.uuid4())
        session_data = {
            "id": session_id,
            "user_id": current_user.id,
            "session_type": "flashcards",
            "chapter_id": chapter_id,
            "started_at": datetime.utcnow().isoformat(),
            "total_cards": flashcards_response["total"]
        }
        
        supabase.table("study_sessions").insert(session_data).execute()
        
        return {
            "session_id": session_id,
            "flashcards": flashcards_response["flashcards"],
            "total_cards": flashcards_response["total"],
            "message": "Flashcard session started"
        }
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to start session: {str(e)}")


@router.post("/review")
async def review_flashcard(
    session_id: str = Query(...),
    flashcard_id: str = Query(...),
    knew_it: bool = Query(..., description="Did you know the answer?"),
    current_user: User = Depends(get_current_user)
):
    """
    Mark a flashcard as reviewed.
    knew_it: True if you got it right, False if you didn't.
    """
    try:
        # Track the review
        review_data = {
            "id": str(uuid.uuid4()),
            "user_id": current_user.id,
            "session_id": session_id,
            "flashcard_id": flashcard_id,
            "knew_it": knew_it,
            "reviewed_at": datetime.utcnow().isoformat()
        }
        
        # Store in a simple tracking table (you can create this or use existing)
        # For now, just return success
        
        return {
            "flashcard_id": flashcard_id,
            "knew_it": knew_it,
            "message": "Review recorded"
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to record review: {str(e)}")


@router.post("/session/{session_id}/end")
async def end_flashcard_session(
    session_id: str,
    cards_reviewed: int = Query(...),
    cards_known: int = Query(...),
    current_user: User = Depends(get_current_user)
):
    """End a flashcard practice session."""
    try:
        # Update session
        supabase.table("study_sessions").update({
            "ended_at": datetime.utcnow().isoformat()
        }).eq("id", session_id).execute()
        
        accuracy = (cards_known / cards_reviewed * 100) if cards_reviewed > 0 else 0
        
        return {
            "session_id": session_id,
            "cards_reviewed": cards_reviewed,
            "cards_known": cards_known,
            "accuracy": round(accuracy, 2),
            "message": "Session completed"
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to end session: {str(e)}")


# ============================================================================
# PROGRESS & STATS
# ============================================================================

@router.get("/stats")
async def get_flashcard_stats(
    current_user: User = Depends(get_current_user)
):
    """Get user's flashcard practice statistics."""
    try:
        # Get all flashcard sessions
        sessions = supabase.table("study_sessions").select("*").eq(
            "user_id", current_user.id
        ).eq("session_type", "flashcards").execute()
        
        if not sessions.data:
            return {
                "total_sessions": 0,
                "total_cards_reviewed": 0,
                "average_accuracy": 0
            }
        
        total_sessions = len(sessions.data)
        total_cards = sum(s.get("total_cards", 0) for s in sessions.data)
        
        return {
            "total_sessions": total_sessions,
            "total_cards_reviewed": total_cards,
            "recent_sessions": sessions.data[:5]
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to get stats: {str(e)}")